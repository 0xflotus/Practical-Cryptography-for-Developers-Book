# ECDSA: Elliptic Curve Digital Signatures

The [**ECDSA**](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) \(Elliptic Curve Digital Signature Algorithm\) is a cryptographically secure **digital signature scheme**, based on the elliptic-curve cryptography \([**ECC**](/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc.md)\). **ECDSA** relies on the math of the **cyclic groups of elliptic curves over finite fields** and on the difficulty of the [**ECDLP problem**](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography#Rationale) \(elliptic-curve discrete logarithm problem\). The [**ECDSA sign / verify**](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) algorithm relies on EC point multiplication and works as described below.

**ECDSA** uses [cryptographic **elliptic curves** \(EC\)](/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc.md) over finite fields in the classical Weierstrass form. These curves are described by their **EC domain parameters**, specified by various cryptographic standards such as [**SECG: SEC 2**](http://www.secg.org/sec2-v2.pdf) and [**Brainpool \(RFC 5639\)**](https://tools.ietf.org/html/rfc5639). Elliptic curves, used in cryptography, define:

* **Generator point** **G**, used for scalar multiplication on the curve \(multiply integer by EC point\)
* **Order **_**n**_ of the subgroup of EC points, generated by **G**, which defines the length of the private keys \(e.g. 256 bits\)

For example, the 256-bit elliptic curve `secp256k1` has:

* Order _**n**_ = 115792089237316195423570985008687907852837564279074904382605163141518161494337 \(prime number\)
* Generator point **G** {_**x**_ = 55066263022277343669578718895168534326250603453777594175500187360389116729240, _**y**_ = 32670510020758816978083085130507043184471273380659243275938904335757337482424}

## Key Generation

The **ECDSA key-pair** consists of:

* private key _**k**_
* public key **K** \(calculated from the private key\)

The **private key** _**k**_ is generated as a **random integer** in the range \[0..._**n**_-1\]. The public key **K** is a point on the elliptic curve, calculated by the EC point multiplication: **K** = _**k **_\* **G**. The public key is EC point {_**x**_, _**y**_} and can be **compressed** to just one of the coordinates + 1 bit \(parity\). For the `secp256k1` curve, the private key is 256-bit integer and the compressed public key is 257-bit integer.

## ECDSA Sign

The ECDSA signing algorithm \([RFC 6979](https://tools.ietf.org/html/rfc6979#section-3.2)\) takes as input a message _**msg**_** **+ a private key _**privKey**_** **and produces as output a **signature**, which consists of pair of integers {_**r**_, _**s**_}. The **ECDSA signing** algorithm works as follows:

1. Calculate the message **hash**, using a cryptographic hash function like SHA-256:
   * _**h**_ = hash\(_**msg**_\)
2. Generate securely a **random** number _**k**_ in the range \[1.._**n**_-1\]
   * In case of **deterministic-ECDSA**, the value _**k**_ is HMAC-derived from _**h**_ + _**privKey**_ \(see [RFC 6979](https://tools.ietf.org/html/rfc6979#section-3.2)\)
3. Calculate the number _**r**_ = x-coordinate of \(_**k**_ \* **G**\) mod _**n**_
4. Calculate _**s**_ = inverse\_mod\(_**k**_, _**n**_\) \* \(_**h**_ + _**privKey**_ \* _**r**_\) mod _**n**_
   * The modular inverse of _**k**_ \(mod _**n**_\) is a number $$ k^-1 \pmod n $$, such that  $$k * k^-1 \equiv 1 \pmod n $$
5. Return the signature {_**r**_, _**s**_}

The calculated **signature** {_**r**_, _**s**_} is a pair of integers, each in the range \[0..._**n**_-1\]. This means that for 256-bit elliptic curves \(like `secp256k1`\),  the ECDSA signature is 512 bits and for 521-bit curves \(like ` secp521r1`\), the signature is 1042 bits.

## ECDSA Verify Signature

The algorithm to **verify a ECDSA signature** takes as input the signed message _**msg**_ + the signature {_**r**_, _**s**_} produced from the signing algorithm + the public key _**pubKey**_, corresponding to the signer's private key. The output is boolean value: _**valid**_ or _**invalid**_ signature. The **ECDSA signature verify** algorithm works as follows:

1. Calculate the message **hash**, using a cryptographic hash function like SHA-256: 
   * _**h**_ = hash\(_**msg**_\)
2. ...
3. ...
4. ...



