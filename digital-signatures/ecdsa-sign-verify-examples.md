# Sign / Verify Messages using ECDSA - Examples in Python

After we explained in details how the **ECDSA signature **algorithm works, now let's demonstrate it in practice with **code examples**.

In this example, we shall use the `pycoin` Python package, which implements the **ECDSA signature algorithm** with the curve `secp256k1` \(used in the Bitcoin cryptography\), as well as many other functionalities related to the Bitcoin blockchain:

```py
pip install pycoin
```

## ECDSA Sign / Verify using the secp256k1 Curve and SHA3-256

First, define the functions for **hashing**, ECDSA **signing** and ECDSA **signature verification**:

```py
from pycoin.ecdsa import generator_secp256k1, sign, verify
import hashlib, secrets

def sha3_256Hash(msg):
    hashBytes = hashlib.sha3_256(msg.encode("utf8")).digest()
    return int.from_bytes(hashBytes, byteorder="big")

def signECDSAsecp256k1(msg, privKey):
    msgHash = sha3_256Hash(msg)
    signature = sign(generator_secp256k1, privKey, msgHash)
    return signature

def verifyECDSAsecp256k1(msg, signature, pubKey):
    msgHash = sha3_256Hash(msg)
    valid = verify(generator_secp256k1, pubKey, msgHash, signature)
    return valid
```

The hashing function `sha3_256Hash(msg)` computes and returns a **SHA3-256** hash, represented as 256-bit integer number. It will be used in the sign / verify processes later.

The `signECDSAsecp256k1(msg, privKey)` function takes a text **message** and 256-bit secp256k1 **private key** and calculates the ECDSA **signature** {_**r**_, _**s**_} and returns it as pair of 256-bit integers. The ECDSA signature, generated by the `pycoin` library by default is **deterministic**, as described in [**RFC 6979**](https://tools.ietf.org/html/rfc6979).

The `verifyECDSAsecp256k1(msg, signature, pubKey)` function takes a text **message**, a ECDSA **signature** {_**r**_, _**s**_} and a 2\*256-bit ECDSA **public key** \(uncompressed\) and returns whether the signature is **valid** or not.

## ECDSA Sign / Verify - Example

Now let's demonstrate the above defined functions to **sign** a message and **verify** its signature:

```py
# ECDSA sign message (using the curve secp256k1 + SHA3-256)
msg = "Message for ECDSA signing"
privKey = secrets.randbelow(generator_secp256k1.order())
signature = signECDSAsecp256k1(msg, privKey)
print("Message:", msg)
print("Private key:", hex(privKey))
print("Signature: r=" + hex(signature[0]) + ", s=" + hex(signature[1]))

# ECDSA verify signature (using the curve secp256k1 + SHA3-256)
pubKey = (generator_secp256k1 * privKey).pair()
valid = verifyECDSAsecp256k1(msg, signature, pubKey)
print("\nMessage:", msg)
print("Public key: (" + hex(pubKey[0]) + ", " + hex(pubKey[1]) + ")")
print("Signature valid?", valid)

# ECDSA verify tampered signature (using the curve secp256k1 + SHA3-256)
msg = "Tampered message"
valid = verifyECDSAsecp256k1(msg, signature, pubKey)
print("\nMessage:", msg)
print("Signature (tampered msg) valid?", valid)
```

The **output** from the above code is like this:

```
Message: Message for ECDSA signing
Private key: 0x79afbf7147841fca72b45a1978dd7669470ba67abbe5c220062924380c9c364b
Signature: r=0xb83380f6e1d09411ebf49afd1a95c738686bfb2b0fe2391134f4ae3d6d77b78a, s=0x6c305afcac930a3ea1721c04d8a1a979016baae011319746323a756fbaee1811

Message: Message for ECDSA signing
Public key: (0x3804a19f2437f7bba4fcfbc194379e43e514aa98073db3528ccdbdb642e240, 0x6b22d833b9a502b0e10e58aac485aa357bccd1df6ec0fa4d398908c1ac1920bc)
Signature valid? True

Message: Tampered message
Signature (tampered msg) valid? False
```

As it is visible from the above output, the random generated **secp256k1 private key **is **64 hex digits** \(256 bits\). After signing, the obtained signature {_**r**_, _**s**_} consists of 2 \* 256-bit integers. The **public key**, obtained by multiplying the private key by the curve generator point, consists of 2 \* 256 bits \(uncompressed\). The produced ECDSA digital signature verifies correctly after signing. If the message is tampered, the signature fails to verify.

## Public Key Recovery from ECDSA Signature

As we already know, in ECDSA it is possible to recover the public key from signature

\[TODO\]

\[TODO\]

\[TODO\]

\[TODO\]

\[TODO\]



